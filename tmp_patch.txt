import React, { useEffect, useMemo, useRef, useState } from 'react'; import { createRoot } from 'react-dom/client'; import 'antd/dist/reset.css'; import { Modal, Input, Button, Checkbox, Divider, message, ConfigProvider, theme, Table as AntTable, Select, Cascader } from 'antd'; import Editor from '@monaco-editor/react'; import { GoogleGenAI } from '@google/genai'; import {     Database,     Table,     Play,     Sparkles,     Settings,     Server,     Plus,     X,     ChevronRight,     ChevronDown,     LayoutGrid,     MessageSquare,     Save,     Eraser,     Wand2,     PanelLeft,     ChevronLeft,     RefreshCw,     Trash2 } from 'lucide-react';  type DbType = 'mysql' | 'postgres' | 'oracle' | 'sqlserver' | 'redis'; type Activity = 'database' | 'history' | 'settings'; type AiProvider = 'google' | 'openai' | 'deepseek' | 'ollama';  interface DatabaseNode {     id: string;     name: string;     expanded: boolean;     tablesExpanded: boolean;     viewsExpanded: boolean;     tables: string[];     views: string[];     loaded?: boolean; }  interface ConnectionNode {     id: string;     name: string;     type: DbType;     host: string;     config?: DbConnectionConfig;     runtimeId?: string | null;     status?: 'idle' | 'connecting' | 'connected' | 'error';     lastError?: string;     expanded: boolean;     databases: DatabaseNode[]; }  interface TabData {     id: string;     title: string;     type: 'query';     initialQuery?: string;     connId?: string | null;     dbName?: string | null; }  interface ChatMessage {     id: string;     role: 'user' | 'model';     text: string;     timestamp: number; }  interface ColumnDefinition {     name: string;     type: string;     length?: number;     decimal?: number;     notNull: boolean;     virtual: boolean;     isKey: boolean;     comment: string; }  type AiConfig = {     provider: AiProvider;     model: string;     temperature: number;     baseUrl: string;     apiKey: string; };  const STORAGE_KEY = 'connections_v1'; const AI_STORAGE_KEY = 'ai_config_v1'; const THEME_STORAGE_KEY = 'theme_preference'; const PROFILE_STORAGE_KEY = 'profile_info_v1'; const ACCENT_STORAGE_KEY = 'accent_color_v1';  declare global {     interface Window {         desktopAPI?: {             connect(config: DbConnectionConfig): Promise<{ id: string; name: string; type: DbType; host: string; database: string }>;             listSchema(payload: { connId: string; database?: string }): Promise<{ databases: DatabaseNode[] }>;             runQuery(payload: { connId: string; sql: string; database?: string }): Promise<{ headers: string[]; rows: any[]; error?: string }>;             close?(payload: { connId: string }): Promise<void>;         };         echarts?: any;     } }  const DEFAULT_PORT: Record<DbType, number> = {     mysql: 3306,     postgres: 5432,     oracle: 1521,     sqlserver: 1433,     redis: 6379 };  const AI_DEFAULT_MODELS: Record<AiProvider, string> = {     google: 'gemini-2.5-flash',     openai: 'gpt-4o-mini',     deepseek: 'deepseek-chat',     ollama: 'llama3' };  const INITIAL_SCHEMA: Record<string, ColumnDefinition[]> = {};  const defaultColumn = (): ColumnDefinition => ({     name: 'new_col',     type: 'VARCHAR',     length: 255,     decimal: undefined,     notNull: false,     virtual: false,     isKey: false,     comment: '' });  const extractJsonFromCode = (raw: string): string => {     const fence = raw.match(/```(?:json)?\s*([\s\S]*?)```/i);     if (fence && fence[1]) return fence[1].trim();     return raw.trim(); };  const parseAiColumns = (raw: string): ColumnDefinition[] => {     const cleaned = extractJsonFromCode(raw);     try {         const parsed = JSON.parse(cleaned);         if (Array.isArray(parsed)) {             return parsed.map((c: any) => {                 const lenNum = Number(c.length);                 const decNum = Number(c.decimal);                 return {                     name: c.name || 'col',                     type: (c.type || 'VARCHAR').toUpperCase(),                     length: Number.isFinite(lenNum) && lenNum > 0 ? lenNum : undefined,                     decimal: Number.isFinite(decNum) && decNum > 0 ? decNum : undefined,                     notNull: !!c.notNull,                     virtual: false,                     isKey: !!c.isKey,                     comment: c.comment || ''                 };             });         }     } catch (err) {         console.warn('parse ai columns failed', err);     }     return []; };  const parseAiTableDesign = (raw: string): { tableName?: string; columns: ColumnDefinition[] } => {     const cleaned = extractJsonFromCode(raw);     try {         const parsed = JSON.parse(cleaned);         if (Array.isArray(parsed)) {             return { columns: parseAiColumns(cleaned) };         }         if (parsed && typeof parsed === 'object') {             const maybeCols = (parsed as any).columns;             const maybeName = typeof (parsed as any).tableName === 'string' ? (parsed as any).tableName : undefined;             if (Array.isArray(maybeCols)) {                 return { tableName: maybeName, columns: parseAiColumns(JSON.stringify(maybeCols)) };             }         }     } catch (err) {         console.warn('parse ai table design failed', err);     }     return { columns: [] }; };  const extractChartOption = (text: string) => {     if (!text) return null;     const body = extractJsonFromCode(text);     try {         const parsed = JSON.parse(body);         if (parsed && typeof parsed === 'object' && (parsed.series || parsed.tooltip || parsed.xAxis || parsed.yAxis)) {             return parsed;         }     } catch (e) {         return null;     }     return null; };  const Resizer = ({ onResize, direction = 'horizontal' }: { onResize: (delta: number) => void; direction?: 'horizontal' | 'vertical' }) => {     const isDragging = useRef(false);     const startPos = useRef(0);     const prefersDark = typeof document !== 'undefined' && document.body?.getAttribute('data-theme') === 'dark';      useEffect(() => {         const handleMove = (e: MouseEvent) => {             if (!isDragging.current) return;             const currentPos = direction === 'horizontal' ? e.clientX : e.clientY;             const delta = currentPos - startPos.current;             onResize(delta);             startPos.current = currentPos;         };         const handleUp = () => {             isDragging.current = false;             document.body.style.cursor = 'default';             document.body.style.userSelect = 'auto';         };          window.addEventListener('mousemove', handleMove);         window.addEventListener('mouseup', handleUp);         return () => {             window.removeEventListener('mousemove', handleMove);             window.removeEventListener('mouseup', handleUp);         };     }, [onResize, direction]);      const cursorClass = direction === 'horizontal' ? 'cursor-col-resize w-1 hover:w-1.5 h-full top-0' : 'cursor-row-resize h-1 hover:h-1.5 w-full left-0';     const themeBg = prefersDark ? 'bg-[#1f1f1f]' : 'bg-slate-200';     const hoverBg = 'hover:bg-blue-500/70';      return (         <div             className={`${cursorClass} ${themeBg} ${hoverBg} transition-all z-50 flex-shrink-0 relative group`}             onMouseDown={(e) => {                 isDragging.current = true;                 startPos.current = direction === 'horizontal' ? e.clientX : e.clientY;                 document.body.style.cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';                 document.body.style.userSelect = 'none';             }}         >             <div className={`absolute bg-transparent ${direction === 'horizontal' ? 'inset-y-0 -left-1 -right-1' : 'inset-x-0 -top-1 -bottom-1'}`} />         </div>     ); };  const ChatChart = ({ option, isDark, ensureEcharts }: { option: any; isDark: boolean; ensureEcharts: () => Promise<any> }) => {     const ref = useRef<HTMLDivElement>(null);      useEffect(() => {         let chart: any;         let disposed = false;         const renderChart = async () => {             try {                 const echarts = await ensureEcharts();                 if (!ref.current || disposed) return;                 chart = echarts.init(ref.current, isDark ? 'dark' : undefined);                 chart.setOption(option, true);             } catch (e) {                 console.warn('render chart failed', e);             }         };         renderChart();         return () => {             disposed = true;             if (chart) chart.dispose();         };     }, [option, isDark, ensureEcharts]);      return <div ref={ref} style={{ width: '100%', height: 260 }} className={`${isDark ? 'bg-[#0f172a]' : 'bg-white'} rounded-md border ${isDark ? 'border-[#1e293b]' : 'border-slate-200'}`} />; };  interface TableEditorModalProps {     open: boolean;     mode: 'create' | 'design';     title: string;     tableName: string;     columns: ColumnDefinition[];     aiPrompt: string;     aiLoading: boolean;     onChangeName: (name: string) => void;     onChangeColumns: (cols: ColumnDefinition[]) => void;     onChangeAiPrompt: (text: string) => void;     onAiGenerate: () => void;     onSave: () => void;     onCancel: () => void;     extraContent?: React.ReactNode; }  const TableEditorModal: React.FC<TableEditorModalProps> = ({                                                                open,                                                                mode,                                                                title,                                                                tableName,                                                                columns,                                                                aiPrompt,                                                                aiLoading,                                                                onChangeName,                                                                onChangeColumns,                                                                onChangeAiPrompt,                                                                onAiGenerate,                                                                onSave,                                                                onCancel,                                                                extraContent                                                            }) => {     const typeOptions = ['BIGINT', 'INTEGER', 'VARCHAR', 'TEXT', 'DATE', 'DATETIME', 'DECIMAL', 'BOOLEAN'];      const updateColumn = (idx: number, patch: Partial<ColumnDefinition>) => {         const copy = [...columns];         copy[idx] = { ...copy[idx], ...patch };         onChangeColumns(copy);     };      const removeColumn = (idx: number) => {         onChangeColumns(columns.filter((_, i) => i !== idx));     };      return (         <Modal             open={open}             title={title}             width={900}             onOk={onSave}             onCancel={onCancel}             okText={mode === 'create' ? '创建' : '保存'}             cancelText="取消"             destroyOnClose             maskClosable={false}             zIndex={1400}         >             <div className="space-y-4">                 {extraContent}                 <div className="flex gap-3 items-start">                     <span className="text-sm w-20 leading-6">AI 生成</span>                     <div className="flex-1 flex gap-2">                         <Input.TextArea                             value={aiPrompt}                             onChange={(e) => onChangeAiPrompt(e.target.value)}                             placeholder="描述业务/表用途，AI 将按此生成表名与字段"                             autoSize={{ minRows: 2, maxRows: 4 }}                         />                         <Button icon={<Sparkles size={14} />} loading={aiLoading} onClick={onAiGenerate} disabled={!aiPrompt.trim()}>                             生成                         </Button>                     </div>                 </div>                 <div className="flex gap-3 items-center">                     <span className="text-sm w-20">表名</span>                     <Input value={tableName} onChange={(e) => onChangeName(e.target.value)} placeholder="table_name" />                 </div>                 <Divider />                 <div className="flex items-center justify-between px-1 mb-2">                     <div className="text-xs uppercase text-gray-500">字段</div>                     <Button size="small" type="dashed" onClick={() => onChangeColumns([...columns, defaultColumn()])}>                         新增字段                     </Button>                 </div>                 <div className="max-h-80 overflow-auto rounded-lg p-2" style={{ borderColor: '#e5e7eb' }}>                     <div className="grid grid-cols-12 gap-2 font-mono text-xs text-gray-500 mb-1 px-1">                         <div className="col-span-2">字段名</div>                         <div className="col-span-2">类型</div>                         <div className="col-span-2">长度</div>                         <div className="col-span-1">精度</div>                         <div className="col-span-1 text-center">非空</div>                         <div className="col-span-1 text-center">虚拟</div>                         <div className="col-span-1 text-center">主键</div>                         <div className="col-span-1 text-center">注释</div>                         <div className="col-span-1" />                     </div>                     <Divider className="my-2" />                     {columns.map((col, idx) => (                         <div key={idx} className="grid grid-cols-12 gap-2 items-center mb-2">                             <Input size="small" value={col.name} onChange={(e) => updateColumn(idx, { name: e.target.value })} className="col-span-2" />                             <Select                                 value={col.type}                                 onChange={(val) => updateColumn(idx, { type: val })}                                 options={typeOptions.map((t) => ({ label: t, value: t }))}                                 size="small"                                 className="col-span-2"                                 style={{ width: '100%' }}                                 popupMatchSelectWidth={false}                             />                             <Input                                 type="number"                                 value={col.length ?? ''}                                 onChange={(e) => updateColumn(idx, { length: e.target.value ? Number(e.target.value) : undefined })}                                 className="col-span-2"                                 size="small"                             />                             <Input                                 type="number"                                 value={col.decimal ?? ''}                                 onChange={(e) => updateColumn(idx, { decimal: e.target.value ? Number(e.target.value) : undefined })}                                 className="col-span-1"                                 size="small"                             />                             <div className="col-span-1 text-center">                                 <Checkbox checked={col.notNull} onChange={(e) => updateColumn(idx, { notNull: e.target.checked })} />                             </div>                             <div className="col-span-1 text-center">                                 <Checkbox checked={col.virtual} onChange={(e) => updateColumn(idx, { virtual: e.target.checked })} />                             </div>                             <div className="col-span-1 text-center">                                 <Checkbox checked={col.isKey} onChange={(e) => updateColumn(idx, { isKey: e.target.checked })} />                             </div>                             <Input value={col.comment} onChange={(e) => updateColumn(idx, { comment: e.target.value })} className="col-span-1" size="small" />                             <Button danger type="link" onClick={() => removeColumn(idx)}>                                 删除                             </Button>                         </div>                     ))}                     {columns.length === 0 && <div className="text-center text-sm opacity-60 py-4">请添加至少一个字段</div>}                 </div>             </div>         </Modal>     ); };  interface ConsoleTabProps {     isActive: boolean;     initialQuery: string;     ai: GoogleGenAI | null;     aiConfig: AiConfig;     activeConnId: string | null;     activeDbName: string | null;     activeTableName: string | null;     connections: ConnectionNode[];     schemaColumns: Record<string, ColumnDefinition[]>;     isDark: boolean;     onOpenRightPanel: () => void;     onRunQuery: (sql: string) => Promise<{ headers: string[]; rows: any[]; error?: string }>;     onChangeConn: (connId: string) => void;     onChangeDb: (dbName: string | null) => void;     onChangeTable: (table: string | null) => void; }  const ConsoleTab: React.FC<ConsoleTabProps> = ({ isActive, initialQuery, ai, aiConfig, activeConnId, activeDbName, activeTableName, connections, schemaColumns, isDark, onOpenRightPanel, onRunQuery, onChangeConn, onChangeDb, onChangeTable }) => {     const [query, setQuery] = useState(initialQuery);     const [results, setResults] = useState<{ headers: string[]; rows: any[]; error: string | null } | null>(null);     const [activeTabResult, setActiveTabResult] = useState<'results' | 'messages'>('results');      const [editorHeight] = useState(360);     const [inlineAiPrompt, setInlineAiPrompt] = useState('');     const [isInlineAiThinking, setIsInlineAiThinking] = useState(false);     const [showInlineAi, setShowInlineAi] = useState(false);     const [pagination, setPagination] = useState({ current: 1, pageSize: 10 });     const [resultsHeight, setResultsHeight] = useState(450);     const [isOptimizingSelection, setIsOptimizingSelection] = useState(false);     const [selectedTable, setSelectedTable] = useState<string | null>(null);     const [chatTargetPath, setChatTargetPath] = useState<string[] | null>(null);     const [simModal, setSimModal] = useState(false);     const [simCount, setSimCount] = useState(10);     const [simHint, setSimHint] = useState('');     const [simTable, setSimTable] = useState<string | null>(null);     const [messageApi, contextHolder] = message.useMessage();     const monacoRef = useRef<any>(null);     const editorRef = useRef<any>(null);     const completionDisposable = useRef<any>(null);     const currentConn = connections.find((c) => c.id === activeConnId);     const currentDb = currentConn?.databases.find((d) => d.name === activeDbName);     const formatValue = (val: any) => {         if (val === null || val === undefined) return 'NULL';         if (val instanceof Date) return val.toISOString();         if (typeof val === 'object') return JSON.stringify(val);         return String(val);     };      const runQuery = async () => {         try {             const res = await onRunQuery(query);             if (res.error) {                 setResults({ headers: res.headers || [], rows: res.rows || [], error: res.error });                 setActiveTabResult('messages');             } else {                 setResults({ headers: res.headers || [], rows: res.rows || [], error: null });                 setActiveTabResult('results');             }         } catch (e: any) {             setResults({ headers: [], rows: [], error: e?.message || String(e) });             setActiveTabResult('messages');         }     };      useEffect(() => {         if (initialQuery && !results) {             runQuery();         }     }, []);      useEffect(() => {         const tables = currentDb?.tables || [];         setSelectedTable((prev) => {             if (activeTableName && tables.includes(activeTableName)) return activeTableName;             if (prev && tables.includes(prev)) return prev;             return tables[0] || null;         });         if (tables.length) {             const targetTable = tables.includes(activeTableName || '') ? activeTableName : tables[0];             setChatTargetPath(activeConnId && activeDbName && targetTable ? [activeConnId, activeDbName, targetTable] : null);             onChangeTable(targetTable || null);         } else {             setChatTargetPath(null);             onChangeTable(null);         }     }, [activeConnId, activeDbName, connections, activeTableName]);      useEffect(() => {         if (activeTableName && activeDbName && activeConnId) {             setChatTargetPath([activeConnId, activeDbName, activeTableName]);         }     }, [activeTableName, activeDbName, activeConnId]);      useEffect(() => {         setPagination((p) => ({ ...p, current: 1 }));     }, [results?.rows?.length]);      const runInlineAi = async (prompt: string, schemaText: string) => {         if (!prompt.trim()) return '';

                                y2: p2.y + cardHeight / 2,                                 from: table,                                 to: targetTable                             });                         }                     }                 }             });         });         return { tablePositions, lines };     };      const erData = useMemo(() => (modals.erDiagram ? generateERConnections() : { tablePositions: {}, lines: [] }), [modals.erDiagram, mockSchema]);      const ensureConnection = async (connId: string, fallback?: ConnectionNode) => {         const conn = connections.find((c) => c.id === connId) || fallback;         if (!conn) throw new Error('连接不存在');         if (!window.desktopAPI) throw new Error('缺少桌面数据库接口 window.desktopAPI');         const cfg: DbConnectionConfig =             conn.config || {                 name: conn.name,                 type: conn.type,                 host: conn.host.split(':')[0],                 port: Number(conn.host.split(':')[1]) || DEFAULT_PORT[conn.type],                 user: 'root',                 password: ''             };         if (conn.runtimeId) return conn.runtimeId;         setConnections((prev) => prev.map((c) => (c.id === connId ? { ...c, status: 'connecting', lastError: undefined } : c)));         try {             const res = await window.desktopAPI.connect(cfg);             setConnections((prev) => prev.map((c) => (c.id === connId ? { ...c, runtimeId: res.id, status: 'connected', lastError: undefined, config: cfg } : c)));             return res.id;         } catch (e: any) {             setConnections((prev) => prev.map((c) => (c.id === connId ? { ...c, status: 'error', lastError: e?.message || String(e) } : c)));             throw e;         }     };      const loadSchemaForConnection = async (connId: string, dbName?: string, runtimeIdOverride?: string | null) => {         const safeDb = typeof dbName === 'string' ? dbName : undefined;         if (!window.desktopAPI) {             showToast('缺少桌面数据库接口，无法刷新连接', 'error');             return { schema: {} as Record<string, ColumnDefinition[]> };         }         let mergedSchema: Record<string, ColumnDefinition[]> = {};         try {             const runtimeId = runtimeIdOverride || (await ensureConnection(connId));             const res = await window.desktopAPI.listSchema({ connId: runtimeId, database: safeDb });             const schemaMap: Record<string, Record<string, ColumnDefinition[]>> = (res as any).schema || {};              if (safeDb) {                 const incoming = (res.databases && res.databases[0]) || { name: safeDb, tables: [], views: [] };                 setConnections((prev) =>                     prev.map((c) => {                         if (c.id !== connId) return c;                         const prevDb = c.databases.find((d) => d.name === incoming.name || d.id === incoming.id);                         const prevTables = prevDb?.tables || [];                         const prevViews = prevDb?.views || [];                         const mergedTables = Array.isArray(incoming.tables) && incoming.tables.length ? incoming.tables : prevTables;                         const mergedViews = Array.isArray(incoming.views) && incoming.views.length ? incoming.views : prevViews;                         const updated = c.databases.map((d) =>                             d.name === incoming.name || d.id === incoming.id                                 ? {                                       ...d,                                       ...incoming,                                       tables: mergedTables,                                       views: mergedViews,                                       expanded: true,                                       tablesExpanded: true,                                       viewsExpanded: true,                                       loaded: true                                   }                                 : d                         );                         if (!updated.find((d) => d.name === incoming.name || d.id === incoming.id)) {                             updated.push({                                 id: incoming.id || `db-${Date.now()}`,                                 name: incoming.name,                                 expanded: true,                                 tablesExpanded: true,                                 viewsExpanded: true,                                 tables: Array.isArray(incoming.tables) ? incoming.tables : [],                                 views: Array.isArray(incoming.views) ? incoming.views : [],                                 loaded: true                             });                         }                         return { ...c, databases: updated, status: 'connected' };                     })                 );             } else {                 setConnections((prev) => {                     const prevConn = prev.find((c) => c.id === connId);                     let databases = (res.databases || []).map((d) => {                         const prevDb = prevConn?.databases.find((p) => p.name === d.name || p.id === d.id);                         const prevTables = prevDb?.tables || [];                         const prevViews = prevDb?.views || [];                         const tablesFromSchema = schemaMap && schemaMap[d.name] ? Object.keys(schemaMap[d.name]) : [];                         return {                             ...d,                             tables: Array.isArray(d.tables) && d.tables.length ? d.tables : tablesFromSchema.length ? tablesFromSchema : prevTables,                             views: Array.isArray(d.views) && d.views.length ? d.views : prevViews,                             expanded: d.expanded ?? false,                             tablesExpanded: d.tablesExpanded ?? false,                             viewsExpanded: d.viewsExpanded ?? false,                             loaded: false                         };                     });                     if ((!databases || databases.length === 0) && schemaMap && Object.keys(schemaMap).length) {                         databases = Object.keys(schemaMap).map((dbName) => {                             const prevDb = prevConn?.databases.find((p) => p.name === dbName);                             const prevTables = prevDb?.tables || [];                             const prevViews = prevDb?.views || [];                             return {                                 id: `db-${dbName}`,                                 name: dbName,                                 expanded: true,                                 tablesExpanded: true,                                 viewsExpanded: false,                                 tables: Object.keys(schemaMap[dbName] || {}) || prevTables,
